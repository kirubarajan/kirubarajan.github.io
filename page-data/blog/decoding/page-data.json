{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/decoding","result":{"data":{"markdownRemark":{"rawMarkdownBody":"\n<div class=\"notification  is-light\">\nDisclaimer: this post is still being written - check back soon for updates!\n</div>\n\n# Decoding Strategies for Text Generation\n> Finding the Humanity in Approximating an NP-Hard Problem\n\n## Introduction\nRecently, machine learning models have seen incredible progress towards computers being able to generate text that sounds human. This is an area of research that involves both furthering our understanding of machine intelligence as well as language usage. I think it’s an interesting problem because it once against prompts a long-standing question in machine intelligence: what does it mean to be human?\n\nSo how do we make computers sound human? In particular, let’s look at the different ways we can do this once we have a special kind of trained machine learning model known as a **language model**. In its simplest sense, a language model assigns a probability to a sequence of words. As you can imagine, language is infinite and so we can’t possibly know the probability of the phrase “cat in the hat”. However, our machine learning model (by definition) is going to **approximate** this likelihood for us. And, as it turns out, this is a powerful technique that works incredibly well for practical purposes.\n\nHere’s a brief (and oversimplified) explanation for how we use language models to generate text. In essence, a language model’s purpose is to give us $P(w|c)$, where $w$ is a particular target word (i.e. the next word) and $c$ is the context that precedes the target word. Now, we can use the chain rule in probability to break down a sequence (or sentence) of words into step-by-step calculations:\n\n$$\nP(\\text{cat in the hat}) = P(\\text{hat} | \\text{the}) \\cdot P(\\text{the} | \\text{in}) \\cdot P(\\text{in} | \\text{cat}) \\cdot P(\\text{cat} | \\text{<START>})\n$$\n\nNow, we turn our focus to using these probabilities to **create** text. Let's determine what the first word of our generation would be. Similar to the previous example, where we have a $\\text{<START>}$ token to signify the beginning of a sequence, we can ask the model what the value of $P(w | \\text{<START>})$ for a variety of different values of $w$. But how do we select what $w$ should be when we're given the probabilities for every possible word? \n\nMore broadly, *how do we select the next word in a sequence, given the probabilities of what following words could be?* As we will see, this is the million dollar question.\n\n## Proving NP-Hardness\nBefore moving on to approaching a solution, it’s worth gaining a little appreciation for how **difficult** this problem truly is. To solve it in its entirety, you would make a million dollars! Literally! The challenges we have with using our machine model to generate text is yet another manifestation of the NP-Complete class of problems (in it’s decision form). If you are unfamiliar, these problems are known to be the toughest problems in computer science. What’s more interesting, is that problems existing in this class can all be **reduced** to one another, implying that they are in essence the same problem.\n\nLet’s show that our issue of text generation is *just as hard* as the other famous NP-hard problems, like the Traveling Salesman Problem and Knapsack Problem. \n\n## Greedy Decoding\n\n## Beam Search\n\n## Random Sampling\n\n## Distribution Changes\n\n### Temperature\n\n### Top-K Sampling\n\n### Top-P Sampling\n\n## Conclusion","html":"<div class=\"notification  is-light\">\nDisclaimer: this post is still being written - check back soon for updates!\n</div>\n<h1>Decoding Strategies for Text Generation</h1>\n<blockquote>\n<p>Finding the Humanity in Approximating an NP-Hard Problem</p>\n</blockquote>\n<h2>Introduction</h2>\n<p>Recently, machine learning models have seen incredible progress towards computers being able to generate text that sounds human. This is an area of research that involves both furthering our understanding of machine intelligence as well as language usage. I think it’s an interesting problem because it once against prompts a long-standing question in machine intelligence: what does it mean to be human?</p>\n<p>So how do we make computers sound human? In particular, let’s look at the different ways we can do this once we have a special kind of trained machine learning model known as a <strong>language model</strong>. In its simplest sense, a language model assigns a probability to a sequence of words. As you can imagine, language is infinite and so we can’t possibly know the probability of the phrase “cat in the hat”. However, our machine learning model (by definition) is going to <strong>approximate</strong> this likelihood for us. And, as it turns out, this is a powerful technique that works incredibly well for practical purposes.</p>\n<p>Here’s a brief (and oversimplified) explanation for how we use language models to generate text. In essence, a language model’s purpose is to give us <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>w</mi><mi mathvariant=\"normal\">∣</mi><mi>c</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(w|c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">c</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span></span></span></span> is a particular target word (i.e. the next word) and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span> is the context that precedes the target word. Now, we can use the chain rule in probability to break down a sequence (or sentence) of words into step-by-step calculations:</p>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mtext>cat in the hat</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mtext>hat</mtext><mi mathvariant=\"normal\">∣</mi><mtext>the</mtext><mo stretchy=\"false\">)</mo><mo>⋅</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mtext>the</mtext><mi mathvariant=\"normal\">∣</mi><mtext>in</mtext><mo stretchy=\"false\">)</mo><mo>⋅</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mtext>in</mtext><mi mathvariant=\"normal\">∣</mi><mtext>cat</mtext><mo stretchy=\"false\">)</mo><mo>⋅</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mtext>cat</mtext><mi mathvariant=\"normal\">∣</mi><mtext>&lt;START&gt;</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(\\text{cat in the hat}) = P(\\text{hat} | \\text{the}) \\cdot P(\\text{the} | \\text{in}) \\cdot P(\\text{in} | \\text{cat}) \\cdot P(\\text{cat} | \\text{&lt;START&gt;})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">cat in the hat</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">hat</span></span><span class=\"mord\">∣</span><span class=\"mord text\"><span class=\"mord\">the</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">the</span></span><span class=\"mord\">∣</span><span class=\"mord text\"><span class=\"mord\">in</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">in</span></span><span class=\"mord\">∣</span><span class=\"mord text\"><span class=\"mord\">cat</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">cat</span></span><span class=\"mord\">∣</span><span class=\"mord text\"><span class=\"mord\">&lt;START&gt;</span></span><span class=\"mclose\">)</span></span></span></span></span>\n<p>Now, we turn our focus to using these probabilities to <strong>create</strong> text. Let's determine what the first word of our generation would be. Similar to the previous example, where we have a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>&lt;START&gt;</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{&lt;START&gt;}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord text\"><span class=\"mord\">&lt;START&gt;</span></span></span></span></span> token to signify the beginning of a sequence, we can ask the model what the value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>w</mi><mi mathvariant=\"normal\">∣</mi><mtext>&lt;START&gt;</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(w | \\text{&lt;START&gt;})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">∣</span><span class=\"mord text\"><span class=\"mord\">&lt;START&gt;</span></span><span class=\"mclose\">)</span></span></span></span> for a variety of different values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span></span></span></span>. But how do we select what <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span></span></span></span> should be when we're given the probabilities for every possible word? </p>\n<p>More broadly, <em>how do we select the next word in a sequence, given the probabilities of what following words could be?</em> As we will see, this is the million dollar question.</p>\n<h2>Proving NP-Hardness</h2>\n<p>Before moving on to approaching a solution, it’s worth gaining a little appreciation for how <strong>difficult</strong> this problem truly is. To solve it in its entirety, you would make a million dollars! Literally! The challenges we have with using our machine model to generate text is yet another manifestation of the NP-Complete class of problems (in it’s decision form). If you are unfamiliar, these problems are known to be the toughest problems in computer science. What’s more interesting, is that problems existing in this class can all be <strong>reduced</strong> to one another, implying that they are in essence the same problem.</p>\n<p>Let’s show that our issue of text generation is <em>just as hard</em> as the other famous NP-hard problems, like the Traveling Salesman Problem and Knapsack Problem. </p>\n<h2>Greedy Decoding</h2>\n<h2>Beam Search</h2>\n<h2>Random Sampling</h2>\n<h2>Distribution Changes</h2>\n<h3>Temperature</h3>\n<h3>Top-K Sampling</h3>\n<h3>Top-P Sampling</h3>\n<h2>Conclusion</h2>","frontmatter":{"title":"Decoding Strategies for Text Generation","date":"2020-04-17","tags":["machine learning"]}}},"pageContext":{"pathSlug":"/blog/decoding"}}}